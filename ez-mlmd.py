#!/usr/bin/env python

import matplotlib.pyplot as plt
import numpy as np
import struct

from keras.models import Sequential
from keras.layers.core import Dense
from keras.optimizers import Adam
from sklearn.model_selection import train_test_split

def process_psf(psf_name):
    ### read PSF file and return index of heavy atoms
    results = []
    with open(psf_name, 'r') as inp_file:
        is_reading_atom_entry = False
        for each_line in inp_file:
            if each_line.startswith(('PSF', '*')):
                continue
            if '!NATOM' in each_line:
                NATOM = int(each_line.split()[0])
                is_reading_atom_entry = True
                atom_counter = 0
                resi_counter = 0
                continue
            if is_reading_atom_entry:
                each_entry = each_line.split()
                if 'H'!=each_entry[4][0]:
                    results.append(int(each_entry[0])-1)
                    # easier index for atoms in dcd  ^^
                if 'CA'==each_entry[4]:
                    resi_counter +=1
                atom_counter += 1
                if atom_counter == NATOM:
                    is_reading_atom_entry = False
    return resi_counter, results

def process_dcd(query_idx, dcd_name):
    with open(dcd_name, 'rb') as inp_file:
        ### Process header1[100]
        fileBuffer = inp_file.read(100)
        NFILE   = struct.unpack("i", fileBuffer[8:12])[0]
        has_pbc = 1==struct.unpack("i",fileBuffer[48:52])[0]
        NTITLE  = struct.unpack("i",fileBuffer[96:])[0]
        ### Process title[NTITLE*80]
        for _ in range(NTITLE):
            fileBuffer = inp_file.read(80)
            # print fileBuffer
        ### Retrieve NATOM from header2[16]
        fileBuffer = inp_file.read(16)
        NATOM  = struct.unpack("i",fileBuffer[8:12])[0]
        xoffset = 15 if has_pbc else 1
        yoffset = NATOM+17 if has_pbc else NATOM+3
        zoofset = 2*NATOM+19 if has_pbc else 2*NATOM+5
        SZFRAME = 3*(4*NATOM+8)+56 if has_pbc else 3*(4*NATOM+8)
        for _ in range(NFILE):
            fileBuffer = inp_file.read(SZFRAME)
            coorBufLen = len(fileBuffer)/3
            ### DCD file format for frame[SZFRAME]: 
            ### 1*int+NATOM*float+1*int + 1*int+NATOM*float+1*int + 1*int+NATOM*float+1*int
            ### ^^^^^^^^^^^^^^^^^^^^^^^x  ^^^^^^^^^^^^^^^^^^^^^^^y  ^^^^^^^^^^^^^^^^^^^^^^^z
            struct_fmt = 'i%dfi'%NATOM
            xcoor = np.array(struct.unpack(struct_fmt, fileBuffer[0*coorBufLen:1*coorBufLen])[1:-1])
            ycoor = np.array(struct.unpack(struct_fmt, fileBuffer[1*coorBufLen:2*coorBufLen])[1:-1])
            zcoor = np.array(struct.unpack(struct_fmt, fileBuffer[2*coorBufLen:3*coorBufLen])[1:-1])
            # center the protein
            xcoor = xcoor - xcoor.mean()
            ycoor = ycoor - xcoor.mean()
            zcoor = zcoor - xcoor.mean()
            yield xcoor[query_idx], ycoor[query_idx], zcoor[query_idx]

def gen_train_data(query_idx, dcd_name, user_label):
    samples = []
    labels  = []
    for xcoor, ycoor, zcoor in process_dcd(heavy_atom_idx, dcd_name):
        samples.append(np.concatenate([xcoor, ycoor, zcoor]))
        labels.append(user_label)
    samples = np.array(samples)
    labels  = np.array(labels).reshape(-1,1)
    return samples, labels

if __name__=='__main__'	:

    ### 0. User input for file IO
    psf_name = '1pgb.psf'
    dcd_name_pos = 'temp300.dcd' # training set all in native state
    dcd_name_neg = 'temp600.dcd' # training set all in unfolded state
    dcd_name_pred = 'pred.dcd'   # trajectory generated by steered molecular dynamics (SMD)

    nresi, heavy_atom_idx = process_psf(psf_name)
    units = nresi

    ### 1. Build model
    model = Sequential([
        Dense(units, activation='relu', input_shape=(3*len(heavy_atom_idx),)),
        Dense(units/2, activation='relu'),
        Dense(units/4, activation='relu'),
        Dense(1, activation='sigmoid')
    ])
    model.compile(Adam(lr=0.001), loss='binary_crossentropy', metrics=["accuracy"])
    print model.summary()

    ### 2. Generate training and testing data
    ts1, tl1  = gen_train_data(heavy_atom_idx, dcd_name_pos, 1) # temperature 300K
    ts2, tl2  = gen_train_data(heavy_atom_idx, dcd_name_neg, 0) # temperature 600K
    x_data = np.concatenate([ts1, ts2])
    y_data = np.concatenate([tl1, tl2])
    x_train, x_test, y_train, y_test = train_test_split(x_data, y_data, test_size=0.2)
    
    ### 3. Run training and testing
    history = model.fit(x_train, y_train, epochs=100, batch_size=100, verbose=0)
    loss, accuracy = model.evaluate(x_test, y_test, verbose=0)
    print "---------------"
    print "Accuracy = %.2f"%accuracy
    print "---------------"

    ### 4. Predicate protein state from SMD simulations
    x_pred, _ = gen_train_data(heavy_atom_idx, dcd_name_pred, -1) # SMD at temperature 300K
    y_pred = model.predict(x_pred)

    ### 5. Save data for future application
    np.savetxt("log-pred.dat", y_pred)
    np.savetxt("log-accu.dat", history.history['acc'])
    np.savetxt("log-loss.dat", history.history['loss'])
    model.save('1pgb.h5')
